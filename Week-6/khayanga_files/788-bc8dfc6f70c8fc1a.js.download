"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[788],{70788:function(e,n,t){t.r(n),t.d(n,{__N_SSG:function(){return C},templates:function(){return g}});var r=t(29815),o=t(85893),s=t(38966),a=t.n(s),i=t(71217),p=t(9008),l=t.n(p),d=t(67294),c=t(28689),u=t(88272),m=t(22560),h="Anonymous maker",b="void setup() {\n  // put your setup code here, to run once:\n\n}\n\nvoid loop() {\n  // put your main code here, to run repeatedly:\n\n}\n",k='void setup() {\n  // put your setup code here, to run once:\n  Serial.begin(115200);\n  Serial.println("Hello, ESP32!");\n}\n\nvoid loop() {\n  // put your main code here, to run repeatedly:\n  delay(10); // this speeds up the simulation\n}\n',_='use esp_idf_sys as _; // If using the `binstart` feature of `esp-idf-sys`, always keep this module imported\n\nfn main() {\n    esp_idf_sys::link_patches();\n    println!("Hello, world!");\n}',w="#![no_std]\n#![no_main]\n\nuse esp32_hal::{clock::ClockControl, pac::Peripherals, prelude::*, timer::TimerGroup, Rtc};\nuse esp_backtrace as _;\nuse xtensa_lx_rt::entry;\n\n#[entry]\nfn main() -> ! {\n    let peripherals = Peripherals::take().unwrap();\n    let system = peripherals.DPORT.split();\n    let clocks = ClockControl::boot_defaults(system.clock_control).freeze();\n\n    // Disable the RTC and TIMG watchdog timers\n    let mut rtc = Rtc::new(peripherals.RTC_CNTL);\n    let timer_group0 = TimerGroup::new(peripherals.TIMG0, &clocks);\n    let mut wdt0 = timer_group0.wdt;\n    let timer_group1 = TimerGroup::new(peripherals.TIMG1, &clocks);\n    let mut wdt1 = timer_group1.wdt;\n\n\n    rtc.rwdt.disable();\n    wdt0.disable();\n    wdt1.disable();\n\n    loop {}\n}\n",f="#![no_std]\n#![no_main]\n\nuse esp32s2_hal::{clock::ClockControl, pac::Peripherals, prelude::*, timer::TimerGroup, Rtc};\nuse esp_backtrace as _;\nuse xtensa_atomic_emulation_trap as _;\nuse xtensa_lx_rt::entry;\n\n#[entry]\nfn main() -> ! {\n    let peripherals = Peripherals::take().unwrap();\n    let system = peripherals.SYSTEM.split();\n    let clocks = ClockControl::boot_defaults(system.clock_control).freeze();\n\n    // Disable the RTC and TIMG watchdog timers\n    let mut rtc = Rtc::new(peripherals.RTC_CNTL);\n    let timer_group0 = TimerGroup::new(peripherals.TIMG0, &clocks);\n    let mut wdt0 = timer_group0.wdt;\n    let timer_group1 = TimerGroup::new(peripherals.TIMG1, &clocks);\n    let mut wdt1 = timer_group1.wdt;\n\n\n    rtc.rwdt.disable();\n    wdt0.disable();\n    wdt1.disable();\n\n    loop {}\n}\n",y='#![no_std]\n#![no_main]\n\nextern crate alloc;\nuse esp32s3_hal::{clock::ClockControl, pac::Peripherals, prelude::*, timer::TimerGroup, Rtc};\nuse esp_backtrace as _;\n#[global_allocator]\nstatic ALLOCATOR: esp_alloc::EspHeap = esp_alloc::EspHeap::empty();\n\nfn init_heap() {\n    const HEAP_SIZE: usize = 32 * 1024;\n\n    extern "C" {\n        static mut _heap_start: u32;\n        static mut _heap_end: u32;\n    }\n\n    unsafe {\n        let heap_start = &_heap_start as *const _ as usize;\n        let heap_end = &_heap_end as *const _ as usize;\n        assert!(\n            heap_end - heap_start > HEAP_SIZE,\n            "Not enough available heap memory."\n        );\n        ALLOCATOR.init(heap_start as *mut u8, HEAP_SIZE);\n    }\n}\n#[xtensa_lx_rt::entry]\nfn main() -> ! {\n    let peripherals = Peripherals::take().unwrap();\n    let system = peripherals.SYSTEM.split();\n    let clocks = ClockControl::boot_defaults(system.clock_control).freeze();\n\n    // Disable the RTC and TIMG watchdog timers\n    let mut rtc = Rtc::new(peripherals.RTC_CNTL);\n    let timer_group0 = TimerGroup::new(peripherals.TIMG0, &clocks);\n    let mut wdt0 = timer_group0.wdt;\n    let timer_group1 = TimerGroup::new(peripherals.TIMG1, &clocks);\n    let mut wdt1 = timer_group1.wdt;\n\n    rtc.rwdt.disable();\n    wdt0.disable();\n    wdt1.disable();\n    esp_println::println!("Hello World!");\n\n    loop {}\n}\n',T="#![no_std]\n#![no_main]\n\nuse esp32c3_hal::{clock::ClockControl, pac::Peripherals, prelude::*, timer::TimerGroup, Rtc};\nuse esp_backtrace as _;\nuse riscv_rt::entry;\n\n#[entry]\nfn main() -> ! {\n    let peripherals = Peripherals::take().unwrap();\n    let system = peripherals.SYSTEM.split();\n    let clocks = ClockControl::boot_defaults(system.clock_control).freeze();\n\n    // Disable the RTC and TIMG watchdog timers\n    let mut rtc = Rtc::new(peripherals.RTC_CNTL);\n    let timer_group0 = TimerGroup::new(peripherals.TIMG0, &clocks);\n    let mut wdt0 = timer_group0.wdt;\n    let timer_group1 = TimerGroup::new(peripherals.TIMG1, &clocks);\n    let mut wdt1 = timer_group1.wdt;\n\n    rtc.swd.disable();\n    rtc.rwdt.disable();\n    wdt0.disable();\n    wdt1.disable();\n\n    loop {}\n}\n  ",M='[package]\nname = "rust_project_esp32c3"\nversion = "0.1.0"\nauthors = ["Your name"]\nedition = "2021"\nlicense = "MIT"\n\n[dependencies]\nesp32c3-hal = "0.2.0"\nesp-backtrace = { version = "0.2.0", features = [\n    "esp32c3",\n    "panic-handler",\n    "print-uart",\n] }\nriscv-rt = { version = "0.9", optional = true }\n\n[features]\ndefault = ["rt"]\nrt = ["riscv-rt"]\n',R={name:"Arduino Uno",boardName:"wokwi-arduino-uno",boardId:"uno",sketch:b},C=!0,g={"arduino-uno":R,"arduino-mega":{name:"Arduino Mega",boardName:"wokwi-arduino-mega",boardId:"mega",sketch:b},"arduino-nano":{name:"Arduino Nano",boardName:"wokwi-arduino-nano",boardId:"nano",sketch:b},attiny85:{name:"ATtiny85",boardName:"wokwi-attiny85",boardId:"tiny",sketch:b},esp32:{name:"ESP32",boardName:"wokwi-esp32-devkit-v1",boardId:"esp",sketch:k,defaultConnections:[["esp:TX0","$serialMonitor:RX",""],["esp:RX0","$serialMonitor:TX",""]]},"esp32-s2":{name:"ESP32-S2",boardName:"board-esp32-s2-devkitm-1",boardId:"esp",sketch:k.replace("ESP32","ESP32-S2"),defaultConnections:[["esp:TX","$serialMonitor:RX",""],["esp:RX","$serialMonitor:TX",""]]},"esp32-s3":{name:"ESP32-S3 (beta)",boardName:"board-esp32-s3-devkitc-1",boardId:"esp",sketch:k.replace("ESP32","ESP32-S3"),defaultConnections:[["esp:TX","$serialMonitor:RX",""],["esp:RX","$serialMonitor:TX",""]]},"esp32-c3":{name:"ESP32-C3",boardName:"board-esp32-c3-devkitm-1",boardId:"esp",sketch:k.replace("ESP32","ESP32-C3"),defaultConnections:[["esp:TX","$serialMonitor:RX",""],["esp:RX","$serialMonitor:TX",""]]},"micropython-esp32":{name:"MicroPython on ESP32",boardName:"wokwi-esp32-devkit-v1",boardId:"esp",boardAttrs:{env:"micropython-20220618-v1.19.1"},sketchName:"main.py",sketch:'print("Hello, ESP32!")\n',defaultConnections:[["esp:TX0","$serialMonitor:RX",""],["esp:RX0","$serialMonitor:TX",""]]},"pi-pico":{name:"Raspberry Pi Pico",boardName:"wokwi-pi-pico",boardId:"pico",sketch:'void setup() {\n  // put your setup code here, to run once:\n  Serial1.begin(115200);\n  Serial1.println("Hello, Raspberry Pi Pico!");\n}\n\nvoid loop() {\n  // put your main code here, to run repeatedly:\n  delay(1); // this speeds up the simulation\n}\n',defaultConnections:[["pico:GP0","$serialMonitor:RX",""],["pico:GP1","$serialMonitor:TX",""]]},"pi-pico-sdk":{name:"Raspberry Pi Pico (SDK)",boardName:"wokwi-pi-pico",boardId:"pico",sketchName:"main.c",sketch:'#include <stdio.h>\n#include "pico/stdlib.h"\n\nint main() {\n  stdio_init_all();\n  while (true) {\n    printf("Hello, Wokwi!\\n");\n    sleep_ms(250);\n  }\n}',boardAttrs:{builder:"pico-sdk"},defaultConnections:[["pico:GP0","$serialMonitor:RX",""],["pico:GP1","$serialMonitor:TX",""]]},"micropython-pi-pico":{name:"MicroPython on Raspberry Pi Pico",boardName:"wokwi-pi-pico",boardId:"pico",boardAttrs:{env:"micropython-20220618-v1.19.1"},sketchName:"main.py",sketch:'print("Hello, Pi Pico!")\n',defaultConnections:[]},"circuitpython-pi-pico":{name:"CircuitPython on Raspberry Pi Pico",boardName:"wokwi-pi-pico",boardId:"pico",boardAttrs:{env:"circuitpython-20210914-8520c43"},sketchName:"code.py",sketch:'print("Hello, Pi Pico!")\n',defaultConnections:[]},franzininho:{name:"Franzininho",boardName:"wokwi-franzininho",boardId:"franzininho",sketch:b},"franzininho-wifi":{name:"Franzininho WiFi (ESP32-S2)",boardName:"board-franzininho-wifi",boardId:"franzininho",sketch:b},"rust-esp32":{name:"Rust on ESP32",boardName:"wokwi-esp32-devkit-v1",boardId:"esp",sketch:_,sketchName:"main.rs",boardAttrs:{builder:"rust-std-esp32"},defaultConnections:[["esp:TX0","$serialMonitor:RX",""],["esp:RX0","$serialMonitor:TX",""]],serialMonitor:{display:"terminal"}},"rust-esp32-s2":{name:"Rust on ESP32-S2",boardName:"board-esp32-s2-devkitm-1",boardId:"esp",sketch:_,sketchName:"main.rs",boardAttrs:{builder:"rust-std-esp32s2"},defaultConnections:[["esp:TX","$serialMonitor:RX",""],["esp:RX","$serialMonitor:TX",""]],serialMonitor:{display:"terminal"}},"rust-esp32-c3":{name:"Rust on ESP32-C3",boardName:"board-esp32-c3-devkitm-1",boardId:"esp",sketch:_,sketchName:"main.rs",boardAttrs:{builder:"rust-std-esp32c3"},defaultConnections:[["esp:TX","$serialMonitor:RX",""],["esp:RX","$serialMonitor:TX",""]],serialMonitor:{display:"terminal"}},"rust-esp32-rust-board":{name:"Rust on ESP32 Rust Board",boardName:"board-esp32-c3-rust-1",boardId:"esp",sketch:_,sketchName:"main.rs",boardAttrs:{builder:"rust-std-esp32c3"},defaultConnections:[["esp:21","$serialMonitor:RX",""],["esp:20","$serialMonitor:TX",""]],serialMonitor:{display:"terminal"}},"rust-nostd-esp32":{name:"Rust on ESP32 (nostd)",boardName:"wokwi-esp32-devkit-v1",boardId:"esp",sketch:w,sketchName:"main.rs",boardAttrs:{builder:"rust-nostd-esp"},defaultConnections:[["esp:TX0","$serialMonitor:RX",""],["esp:RX0","$serialMonitor:TX",""]],serialMonitor:{display:"terminal"},extraFiles:[{name:"Cargo.toml",content:'[package]\nname = "rust_project_esp32"\nversion = "0.1.0"\nauthors = ["Your name"]\nedition = "2021"\nlicense = "MIT"\n\n[dependencies]\nesp32-hal = "0.5.0"\nesp-backtrace = { version = "0.2.0", features = [\n    "esp32",\n    "panic-handler",\n    "print-uart",\n] }\nxtensa-lx-rt = { version = "0.13.0", features = ["esp32"], optional = true }\n\n[features]\ndefault = ["rt"]\nrt = ["xtensa-lx-rt"]\n'}]},"rust-nostd-esp32-s2":{name:"Rust on ESP32-S2 (nostd)",boardName:"board-esp32-s2-devkitm-1",boardId:"esp",sketch:f,sketchName:"main.rs",boardAttrs:{builder:"rust-nostd-esp"},defaultConnections:[["esp:TX","$serialMonitor:RX",""],["esp:RX","$serialMonitor:TX",""]],serialMonitor:{display:"terminal"},extraFiles:[{name:"Cargo.toml",content:'[package]\nname = "rust_project_esp32s2"\nversion = "0.1.0"\nauthors = ["Your name"]\nedition = "2021"\nlicense = "MIT"\n\n[dependencies]\nesp32s2-hal = "0.2.0"\nesp-println = { version = "0.3.0", features = ["esp32s2"] }\nesp-backtrace = { version = "0.2.0", features = [\n    "esp32s2",\n    "panic-handler",\n    "print-uart",\n] }\nxtensa-atomic-emulation-trap = "0.2.0"\nxtensa-lx-rt = { version = "0.13.0", features = ["esp32s2"], optional = true }\n\n[features]\ndefault = ["rt"]\nrt = ["xtensa-lx-rt"]\n'}]},"rust-nostd-esp32-s3":{name:"Rust on ESP32-S3 (nostd)",boardName:"board-esp32-s3-devkitc-1",boardId:"esp",sketch:y,sketchName:"main.rs",boardAttrs:{builder:"rust-nostd-esp"},defaultConnections:[["esp:TX","$serialMonitor:RX",""],["esp:RX","$serialMonitor:TX",""]],serialMonitor:{display:"terminal"},extraFiles:[{name:"Cargo.toml",content:'[package]\nname = "rust_project_esp32s3"\nversion = "0.1.0"\nauthors = ["Sergio Gasquez <sergio.gasquez@gmail.com>"]\nedition = "2021"\nlicense = "MIT OR Apache-2.0"\n\n[dependencies]\nesp32s3-hal = "0.3.0"\nesp-alloc = { version = "0.1.0", features = ["oom-handler"] }\nesp-backtrace = { version = "0.3.0", features = ["esp32s3", "panic-handler", "print-uart"] }\nesp-println = { version = "0.3.1", features = ["esp32s3"] }\nxtensa-lx-rt = { version = "0.13.0", features = ["esp32s3"], optional = true }\n\n[features]\ndefault = ["rt"]\nrt = ["xtensa-lx-rt"]\n'}]},"rust-nostd-esp32-c3":{name:"Rust on ESP32-C3 (nostd)",boardName:"board-esp32-c3-devkitm-1",boardId:"esp",sketch:T,sketchName:"main.rs",boardAttrs:{builder:"rust-nostd-esp"},defaultConnections:[["esp:TX","$serialMonitor:RX",""],["esp:RX","$serialMonitor:TX",""]],serialMonitor:{display:"terminal"},extraFiles:[{name:"Cargo.toml",content:M}]},"rust-nostd-esp32-rust-board":{name:"Rust on ESP32 Rust Board (nostd)",boardName:"board-esp32-c3-rust-1",boardId:"esp",sketch:T,sketchName:"main.rs",boardAttrs:{builder:"rust-nostd-esp"},defaultConnections:[["esp:21","$serialMonitor:RX",""],["esp:20","$serialMonitor:TX",""]],serialMonitor:{display:"terminal"},extraFiles:[{name:"Cargo.toml",content:M}]}},v=function(e){var n=e.boardName,t=e.boardId,r=e.boardAttrs,o=e.defaultConnections,s=e.serialMonitor;return a()({version:1,author:h,editor:"wokwi",parts:[{id:t,type:n,attrs:r}],connections:null!==o&&void 0!==o?o:[],serialMonitor:s},null,2,100)};function P(e){var n,t;return[{name:null!==(n=e.sketchName)&&void 0!==n?n:"sketch.ino",content:e.sketch},{name:"diagram.json",content:v(e)}].concat((0,r.Z)(null!==(t=e.extraFiles)&&void 0!==t?t:[]))}n.default=(0,i.Pi)((function(e){var n=e.templateName,t=g[null!==n&&void 0!==n?n:""]||R,r=(0,u.a)(),s=(0,d.useMemo)((function(){return m.IK.create({files:P(t)})}),[t]),a=r.displayName;(0,d.useEffect)((function(){var e=s.diagram;a&&e&&e.author===h&&(e.undoManager.withoutUndo((function(){e.setAuthor(a)})),s.syncDiagram())}),[s,s.diagram,a]);var i="New ".concat(t.name," Project - Wokwi Simulator"),p="Create a new ".concat(t.name," simulation project, run it in your browser and share your code and schematics.");return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(l(),{children:[(0,o.jsx)("title",{children:i}),(0,o.jsx)("meta",{name:"description",content:p}),(0,o.jsx)("meta",{property:"og:title",content:i}),(0,o.jsx)("meta",{property:"og:description",content:p}),(0,o.jsx)("meta",{property:"og:image",content:"https://thumbs.wokwi.com/api/render.png?service=wokwi&path=/projects/new/".concat(n)}),(0,o.jsx)("meta",{property:"og:image:type",content:"image/png"}),(0,o.jsx)("meta",{property:"og:image:width",content:"1200"}),(0,o.jsx)("meta",{property:"og:image:height",content:"630"})]}),(0,o.jsx)(c.m,{project:s})]})}))}}]);